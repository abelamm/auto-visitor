/**
 * Auto-Visitor - Browser Automation Traffic Tool
 * Complete, production-ready implementation
 * 
 * Features:
 * - Stealth mode (evades bot detection)
 * - Free proxy support (20+ quality proxies built-in)
 * - Concurrent browser automation
 * - Human-like behavior simulation
 * - Comprehensive error handling
 * - Automatic retry logic
 * - Beautiful reporting
 */

const { Builder, By, until } = require('selenium-webdriver');
const chrome = require('selenium-webdriver/chrome');
const { EventEmitter } = require('events');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

/**
 * Proxy Provider - Fetches free proxies from multiple sources
 */
class ProxyProvider extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = {
      minQuality: config.minQuality || 0.7,
      timeout: config.timeout || 10000,
      ... config
    };
  }

  async fetchFromProxyScrape() {
    try {
      const response = await axios.get(
        'https://api.proxyscrape.com/v2/?request=get&protocol=http&timeout=10000&ssl=all&anonymity=all&country=all&limit=50&format=textplain',
        { timeout: this.config.timeout }
      );

      const proxies = [];
      if (response.data) {
        const lines = response.data.trim().split('\n');
        lines.forEach((line) => {
          if (line && line.includes(':')) {
            const [ip, port] = line.split(':');
            proxies.push({
              proxy: `http://${ip}:${port}`,
              ip,
              port,
              uptime: 0. 8,
              source: 'proxyscrape. com'
            });
          }
        });
      }
      return proxies;
    } catch (error) {
      return [];
    }
  }

  async fetchFromProxyListDownload() {
    try {
      const response = await axios. get(
        'https://www.proxy-list.download/api/v1/get? type=http',
        { timeout: this.config.timeout }
      );

      const proxies = [];
      if (response.data && response.data. LISTA) {
        response.data. LISTA.forEach((item) => {
          proxies.push({
            proxy: `http://${item.IP}:${item.PORT}`,
            ip: item.IP,
            port: item.PORT,
            uptime: 0.75,
            source: 'proxy-list.download'
          });
        });
      }
      return proxies;
    } catch (error) {
      return [];
    }
  }

  async fetchAll() {
    console.log('[PROXY] Fetching free proxies from multiple sources...\n');

    const results = await Promise.allSettled([
      this.fetchFromProxyScrape(),
      this.fetchFromProxyListDownload()
    ]);

    const allProxies = [];
    results.forEach((result) => {
      if (result. status === 'fulfilled') {
        allProxies.push(... result.value);
      }
    });

    // Remove duplicates
    const uniqueProxies = [];
    const seen = new Set();

    allProxies.forEach((p) => {
      if (!seen.has(p.proxy)) {
        seen.add(p. proxy);
        uniqueProxies.push(p);
      }
    });

    // Sort by quality
    uniqueProxies.sort((a, b) => b.uptime - a.uptime);

    console.log(`[PROXY] ‚úì Found ${uniqueProxies.length} total proxies`);
    console. log(`[PROXY] ‚úì Sorted by quality\n`);

    return uniqueProxies;
  }

  async getTopProxies(count = 20) {
    const allProxies = await this.fetchAll();
    return allProxies.slice(0, count). map((p) => p.proxy);
  }

  async validateProxy(proxy) {
    try {
      const response = await axios.get('https://httpbin.org/ip', {
        httpAgent: new (require('http-proxy-agent'))(proxy),
        httpsAgent: new (require('https-proxy-agent'))(proxy),
        timeout: 5000
      });
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }

  async validateProxies(proxies, concurrent = 5) {
    console.log(`[PROXY] Validating ${proxies.length} proxies.. .\n`);

    const validated = [];

    for (let i = 0; i < proxies.length; i += concurrent) {
      const batch = proxies.slice(i, i + concurrent);
      const results = await Promise.allSettled(
        batch.map((p) => this. validateProxy(p))
      );

      results.forEach((result, index) => {
        if (result.status === 'fulfilled' && result.value) {
          validated. push(batch[index]);
          console.log(`[PROXY] ‚úì ${batch[index]}`);
        } else {
          console.log(`[PROXY] ‚úó ${batch[index]}`);
        }
      });
    }

    console.log(`\n[PROXY] ‚úì ${validated.length}/${proxies.length} proxies working\n`);
    return validated;
  }
}

/**
 * Main Auto-Visitor Class
 */
class AutoVisitor extends EventEmitter {
  constructor(config = {}) {
    super();
    this.config = {
      headless: config.headless !== false,
      timeout: config.timeout || 30000,
      concurrency: config.concurrency || 3,
      minVisitTime: config.minVisitTime || 8000,
      maxVisitTime: config.maxVisitTime || 40000,
      useProxy: config.useProxy !== false,
      useFreeProxies: config. useFreeProxies !== false,
      proxyCount: config.proxyCount || 20,
      retryAttempts: config.retryAttempts || 3,
      retryDelay: config.retryDelay || 5000,
      logLevel: config.logLevel || 'info',
      validateProxies: config.validateProxies !== false,
      validateFreeProxies: config.validateFreeProxies !== false,
      ...config
    };

    this.drivers = [];
    this.proxies = [];
    this.proxyIndex = 0;
    this. proxyProvider = new ProxyProvider();
    this.stats = {
      total: 0,
      success: 0,
      failed: 0,
      errors: [],
      retries: 0,
      start: null,
      end: null
    };

    this.logger = this.createLogger();
  }

  /**
   * Create logger with configurable levels
   */
  createLogger() {
    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
    const currentLevel = levels[this.config.logLevel] || 1;

    return {
      debug: (msg) => currentLevel <= 0 && console.log(`[DEBUG] ${msg}`),
      info: (msg) => currentLevel <= 1 && console. log(`[INFO] ${msg}`),
      warn: (msg) => currentLevel <= 2 && console.warn(`[WARN] ${msg}`),
      error: (msg) => currentLevel <= 3 && console.error(`[ERROR] ${msg}`)
    };
  }

  /**
   * Auto-load free proxies
   */
  async autoLoadFreeProxies() {
    if (!this.config.useFreeProxies || this.proxies.length > 0) {
      return;
    }

    try {
      this.logger.info('üîÑ Fetching free proxies.. .\n');

      const proxies = await this. proxyProvider.getTopProxies(this.config.proxyCount);

      if (proxies.length === 0) {
        this.logger. warn('No free proxies available, running without proxies');
        this.config.useProxy = false;
        return;
      }

      this. logger.info(`‚úì Loaded ${proxies.length} free proxies\n`);

      if (this.config.validateFreeProxies) {
        this.logger.info('Validating free proxies...');
        const validated = await this. proxyProvider.validateProxies(proxies, 3);
        this.proxies = validated;
      } else {
        this.proxies = proxies;
      }

      if (this.proxies.length === 0) {
        this.logger.warn('All proxies failed validation, running without proxies');
        this.config.useProxy = false;
      } else {
        this.logger.info(`‚úì ${this.proxies.length} proxies ready\n`);
      }
    } catch (error) {
      this.logger.warn(`Failed to auto-load proxies: ${error.message}`);
      this.config.useProxy = false;
    }
  }

  /**
   * Load proxies from array or file
   */
  async loadProxies(proxyList) {
    if (! proxyList) return;

    try {
      let proxies = [];

      if (Array.isArray(proxyList)) {
        proxies = proxyList;
      } else if (typeof proxyList === 'string') {
        if (! fs.existsSync(proxyList)) {
          this.logger.warn(`Proxy file not found: ${proxyList}`);
          return;
        }
        const content = fs.readFileSync(proxyList, 'utf-8');
        proxies = content
          .split('\n')
          .map((p) => p.trim())
          .filter((p) => p && !p.startsWith('#'));
      }

      this.proxies = proxies. filter((p) => p);
      this. logger.info(`‚úì Loaded ${this.proxies.length} proxies`);

      if (this.config.validateProxies) {
        await this.validateProxies();
      }
    } catch (error) {
      this.logger.error(`Failed to load proxies: ${error.message}`);
    }
  }

  /**
   * Validate proxy connectivity
   */
  async validateProxies() {
    if (this.proxies.length === 0) return;

    this.logger.info('üîç Validating proxies...');
    const valid = [];

    for (const proxy of this.proxies) {
      try {
        const [ip, port] = proxy
          .replace('http://', '')
          . replace('https://', '')
          .split(':');
        const response = await axios.get('https://httpbin.org/ip', {
          httpAgent: new (require('http-proxy-agent'))(`http://${ip}:${port}`),
          httpsAgent: new (require('https-proxy-agent'))(`http://${ip}:${port}`),
          timeout: 5000
        });
        valid.push(proxy);
        this.logger. debug(`  ‚úì ${proxy}`);
      } catch (error) {
        this.logger.debug(`  ‚úó ${proxy}`);
      }
    }

    this.proxies = valid;
    const total = this.proxies.length;
    this.logger.info(`‚úì ${valid.length} proxies working\n`);
  }

  /**
   * Get next proxy from rotation
   */
  getNextProxy() {
    if (this.proxies.length === 0) return null;
    const proxy = this.proxies[this. proxyIndex % this.proxies.length];
    this.proxyIndex++;
    return proxy;
  }

  /**
   * Build WebDriver instance
   */
  async buildDriver(proxy = null) {
    try {
      let options = new chrome.Options();

      if (this.config.headless) {
        options.addArguments('--headless=new');
      }

      options.addArguments(
        '--no-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--disable-extensions',
        '--disable-plugins',
        '--disable-blink-features=AutomationControlled',
        '--window-size=1920,1080',
        '--start-maximized'
      );

      if (proxy) {
        options.addArguments(`--proxy-server=${proxy}`);
        this.logger.debug(`Using proxy: ${proxy}`);
      }

      options.addArguments(`user-agent=${this.getRandomUserAgent()}`);

      const driver = await new Builder()
        .forBrowser('chrome')
        . setChromeOptions(options)
        .build();

      await driver.manage().setTimeouts({
        implicit: this.config. timeout,
        pageLoad: this.config.timeout,
        script: this.config.timeout
      });

      this.logger.debug('‚úì Driver initialized');
      return driver;
    } catch (error) {
      this.logger.error(`Driver initialization failed: ${error.message}`);
      throw new Error(`WebDriver Error: ${error.message}`);
    }
  }

  /**
   * Get random user agent
   */
  getRandomUserAgent() {
    const agents = [
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Mozilla/5. 0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',
      'Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1',
      'Mozilla/5.0 (Linux; Android 13; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120. 0.0.0 Mobile Safari/537.36'
    ];
    return agents[Math.floor(Math.random() * agents.length)];
  }

  /**
   * Sleep with random delay
   */
  sleep(min, max) {
    const delay = Math.floor(Math.random() * (max - min + 1)) + min;
    return new Promise((r) => setTimeout(r, delay));
  }

  /**
   * Simulate human-like behavior
   */
  async simulateBehavior(driver) {
    try {
      const scrollCount = Math.floor(Math.random() * 3) + 1;
      for (let i = 0; i < scrollCount; i++) {
        await driver.executeScript('window.scrollBy(0, window.innerHeight / 2);');
        await this.sleep(1000, 3000);
      }

      try {
        const elements = await driver.findElements(By.css('a, button'));
        if (elements.length > 0) {
          const randomElement = elements[Math.floor(Math.random() * elements. length)];
          await driver.executeScript('arguments[0].scrollIntoView();', randomElement);
          await this.sleep(500, 1500);

          try {
            await randomElement.click();
          } catch (e) {
            this.logger.debug(`Could not click element`);
          }
        }
      } catch (e) {
        this.logger.debug(`Element interaction failed`);
      }

      await this.sleep(this.config.minVisitTime, this.config.maxVisitTime);
      return true;
    } catch (error) {
      this.logger. warn(`Behavior simulation error: ${error.message}`);
      return false;
    }
  }

  /**
   * Categorize error type
   */
  categorizeError(error) {
    const message = error.message. toLowerCase();

    if (message.includes('timeout')) return 'TIMEOUT';
    if (message. includes('connection')) return 'CONNECTION_ERROR';
    if (message. includes('proxy')) return 'PROXY_ERROR';
    if (message.includes('navigation')) return 'NAVIGATION_ERROR';
    if (message.includes('error')) return 'PAGE_ERROR';
    if (message.includes('element')) return 'ELEMENT_ERROR';
    if (message.includes('script')) return 'SCRIPT_ERROR';
    if (message.includes('certificate')) return 'SSL_ERROR';

    return 'UNKNOWN_ERROR';
  }

  /**
   * Visit URL with retry logic
   */
  async visitUrl(url, driverIndex, attempt = 1) {
    let driver = null;
    const proxy = this.config.useProxy ? this.getNextProxy() : null;

    try {
      driver = this.drivers[driverIndex] || (await this.buildDriver(proxy));
      if (!this.drivers[driverIndex]) {
        this.drivers[driverIndex] = driver;
      }

      try {
        await driver.get(url);
      } catch (navigationError) {
        if (navigationError.name === 'TimeoutError') {
          this. logger.warn(`Navigation timeout for ${url}`);
          throw new Error('NAVIGATION_TIMEOUT');
        }
        throw navigationError;
      }

      try {
        await driver.wait(until.elementLocated(By.css('body')), 10000);
      } catch (e) {
        this.logger.warn(`Body element not found`);
      }

      const pageTitle = await driver.getTitle();
      if (pageTitle.toLowerCase().includes('error') || pageTitle.toLowerCase().includes('blocked')) {
        throw new Error('ERROR_PAGE_DETECTED');
      }

      await this.simulateBehavior(driver);

      this.stats.success++;
      this.logger.info(`‚úì #${this.stats.total}: ${url. substring(0, 50)}...`);
      this.emit('visit-success', { url, attempt, proxy });

      return true;
    } catch (error) {
      const errorCode = this.categorizeError(error);
      this.stats.failed++;

      this.logger.warn(`‚úó #${this.stats. total}: ${errorCode}`);

      this.stats.errors.push({
        url,
        attempt,
        error: error.message,
        errorCode,
        timestamp: new Date()
      });

      if (attempt < this.config.retryAttempts) {
        this. stats.retries++;
        this. logger.info(`‚ü≥ Retrying (${attempt + 1}/${this. config.retryAttempts})...`);

        if (driver) {
          try {
            await driver.quit();
            this.drivers[driverIndex] = null;
          } catch (e) {
            this.logger. debug(`Error closing driver`);
          }
        }

        await this.sleep(this.config.retryDelay, this.config.retryDelay + 2000);
        return await this.visitUrl(url, driverIndex, attempt + 1);
      }

      this.emit('visit-failed', { url, errorCode, proxy });
      return false;
    } catch (fatalError) {
      this. logger.error(`Fatal error: ${fatalError.message}`);
      this.stats.failed++;
      return false;
    }
  }

  /**
   * Start visit campaign
   */
  async start(url, numberOfVisits) {
    console.log(`\nüöÄ Starting ${numberOfVisits} visits to ${url}`);
    console.log('‚ïê'.repeat(70) + '\n');

    if (! url. startsWith('http://') && !url.startsWith('https://')) {
      this.logger.error('Invalid URL - must start with http:// or https://');
      process.exit(1);
    }

    if (this.config.useFreeProxies && this.proxies.length === 0) {
      await this.autoLoadFreeProxies();
    }

    this.stats.total = numberOfVisits;
    this.stats.start = Date.now();

    this.logger.info(`Initializing ${this.config.concurrency} drivers.. .\n`);

    const visits = [];
    for (let i = 0; i < numberOfVisits; i++) {
      const driverIndex = i % this.config.concurrency;
      visits.push(this.visitUrl(url, driverIndex));

      if ((i + 1) % this. config.concurrency === 0 && i < numberOfVisits - 1) {
        await this. sleep(2000, 5000);
      }
    }

    await Promise.allSettled(visits);

    this.stats.end = Date.now();
    await this.cleanup();
    this.showReport();
  }

  /**
   * Cleanup all drivers
   */
  async cleanup() {
    this.logger.info('\nüßπ Closing drivers...');

    for (const driver of this. drivers) {
      if (driver) {
        try {
          await driver.quit();
        } catch (error) {
          this.logger. debug(`Error closing driver`);
        }
      }
    }

    this.drivers = [];
  }

  /**
   * Display final report
   */
  showReport() {
    const duration = (this.stats.end - this.stats.start) / 1000;
    const rate = ((this.stats.success / this.stats.total) * 100).toFixed(1);

    console.log('‚ïê'.repeat(70));
    console.log('üìä REPORT');
    console.log('‚ïê'.repeat(70));
    console.log(`Total Visits:       ${this.stats.total}`);
    console.log(`Successful:         ${this.stats.success}`);
    console.log(`Failed:             ${this.stats. failed}`);
    console.log(`Success Rate:       ${rate}%`);
    console.log(`Retries Triggered:  ${this.stats.retries}`);
    console.log(`Duration:           ${duration. toFixed(2)}s`);
    console. log(`Avg Time/Visit:     ${(duration / this.stats.total). toFixed(2)}s`);
    console.log(`Visits/Second:      ${(this.stats.success / duration).toFixed(2)}`);
    console.log(`Proxies Used:       ${this.proxies.length > 0 ? this.proxies.length : 'None'}`);
    console. log('‚ïê'.repeat(70));

    if (this.stats. errors.length > 0) {
      console.log('\n‚ö†Ô∏è  ERROR BREAKDOWN');
      console.log('‚ïê'.repeat(70));

      const errorCounts = {};
      this.stats.errors.forEach((err) => {
        errorCounts[err.errorCode] = (errorCounts[err.errorCode] || 0) + 1;
      });

      Object.entries(errorCounts)
        .sort((a, b) => b[1] - a[1])
        .forEach(([code, count]) => {
          console.log(`  ${code}: ${count}`);
        });

      console.log('‚ïê'.repeat(70));
    }

    console.log();
  }

  /**
   * Get detailed statistics
   */
  getStats() {
    return {
      summary: {
        total: this. stats.total,
        successful: this.stats.success,
        failed: this.stats.failed,
        successRate: `${((this.stats.success / this.stats.total) * 100).toFixed(1)}%`,
        retries: this. stats.retries
      },
      errors: this. stats.errors,
      duration: (this.stats.end - this. stats.start) / 1000,
      proxiesUsed: this.proxies. length
    };
  }
}

module.exports = AutoVisitor;